# Instrucciones y Registros de CPU

## Instrucciones

Una **instrucción** en lenguaje ensamblador es un **comando de bajo nivel** hacia la CPU. Típicamente consiste de:

```cpp
   [Label:] nmemonic operand1, operand2   ; optional comment
```

En sintaxis Intel el formato siempre es

```bash
   operation destination, source
```

### Componentes de una Instrucción

1. Etiqueta (Opcional):
   - Nombre simbólico para una dirección de memoria.
   - Se usa para saltos, ciclos y funciones.

```asm
   start:
```

2. Mnemónico (Nombre de la Instrucción):
   - Le indica a la CPU *que operación* ejecutar.
   - Ejemplos: `mov`, `add`, `jmp`, `cmp`, `call`, `ret`

```asm
   mov eax, 1  ; move 1 into the eax register
```

3. Operandos (Opcional)

   - Los *datos* sobre los que trabaja la instrucción.
   - Sintaxis Intel: destination, source

```asm
   add eax, ebx  ; eax = eax + ebx
```

### Tipos de Operandos

| Tipo          | Ejemplo            | Funcionamiento                     |
|---------------|--------------------|------------------------------------|
| Registro      | `eax`, `rbx`       | Registro de la CPU                 |
| Inmediato     | `5`, `0xFF`        | Valor en duro                      |
| Memoria       | `[ebx]`, `[rsp+8]` | Ubicación de memoria con dirección |

```asm
   mov eax, 5     ; inmediate to register
   mov eax, [ebx] ; memory to register
   mov [ebx], eax ; register to memory 
```

### Traducción a Lenguaje de Máquina

Cada instrucción se compila finalmente a un código de operación binario (*opcode*), que es ejecutado por la CPU. Por ejemplo:

```asm
   mov eax, 1
```

Se transforma en:

```asm
   b8 01 00 00 00
```

- `b8` es el *opcode* para `mov eax, imm32`

### Desglose de una Instrucción

```asm
   mov [rbp-4], eax  ; Store eax into local variable
```

- `mov`: Mover los datos.
- `[rbp-4]`: Destino (dirección de memoria, distancia desde el puntero base)
- `eax`: Origen (registro)
- La CPU escribirá el contenido de `eax` en la memoria ubicada en la dirección `[rbp-4]`

### Ejercicio Práctico 1.1: Repaso de Instrucciones

1. Compilar el archivo `1_1_instrucciones.c` con información de depuración y sintaxis de Intel, usando `gcc`.

```bash
   gcc -v -masm=intel -g ./1_1_instrucciones.c -o 1_1_instrucciones
```

2. Iniciar `gdb` y establecer un *breakpoint*

```bash
   gdb ./1_1_instrucciones
   break main
   run
   # When the program stops at main, disassemble it
   disas
```

3. Analizar las instrucciones

Verás unas instrucciones similares a estas:

```asm
      0x0000555555555139 <+0>:     push   rbp
      0x000055555555513a <+1>:     mov    rbp,rsp
      0x000055555555513d <+4>:     sub    rsp,0x10
   => 0x0000555555555141 <+8>:     mov    DWORD PTR [rbp-0x4],0x5
      0x0000555555555148 <+15>:    mov    DWORD PTR [rbp-0x8],0x3
      0x000055555555514f <+22>:    mov    edx,DWORD PTR [rbp-0x4]
      0x0000555555555152 <+25>:    mov    eax,DWORD PTR [rbp-0x8]
      0x0000555555555155 <+28>:    add    eax,edx
      0x0000555555555157 <+30>:    mov    DWORD PTR [rbp-0xc],eax
```

4. Analicemos una en detalle

```asm
   mov   DWORD PTR [rbp-0x4],0x5
```

   - `mov`        Mnemónico de la instrucción
   - `DWORD PTR`  Tamaño de operando (32 bits, double word)
   - `[rbp-4]`    Operando de memoria, variable local en el stack
   - `0x5`        Valor inmediato (Entero literal)

5. Recorrer las instrucciones

```bash
   (gdb) si             ; Step one instruction (use `ni` for next)
   (gdb) info registers
```

Se puede observar como los registros `eax`, `rbp`, `rsp` y otros cambian a medida que se ejecuta el programa.

Para observar la memoria:

```bash
   (gdb) x/4xw $rsp       ; examine 4 words on the stack
   (gdb) x/dw $rbp - 4    ; view local variable as decimal
```